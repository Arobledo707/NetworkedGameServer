// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protoTest.proto

#ifndef PROTOBUF_protoTest_2eproto__INCLUDED
#define PROTOBUF_protoTest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protoTest_2eproto();
void protobuf_InitDefaults_protoTest_2eproto();
void protobuf_AssignDesc_protoTest_2eproto();
void protobuf_ShutdownFile_protoTest_2eproto();

class Army;
class Game;
class Leaderboard;
class Player;

enum Player_PlayerState {
  Player_PlayerState_Lobby = 0,
  Player_PlayerState_InGame = 1,
  Player_PlayerState_LoggedOut = 2,
  Player_PlayerState_Challenged = 3
};
bool Player_PlayerState_IsValid(int value);
const Player_PlayerState Player_PlayerState_PlayerState_MIN = Player_PlayerState_Lobby;
const Player_PlayerState Player_PlayerState_PlayerState_MAX = Player_PlayerState_Challenged;
const int Player_PlayerState_PlayerState_ARRAYSIZE = Player_PlayerState_PlayerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* Player_PlayerState_descriptor();
inline const ::std::string& Player_PlayerState_Name(Player_PlayerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    Player_PlayerState_descriptor(), value);
}
inline bool Player_PlayerState_Parse(
    const ::std::string& name, Player_PlayerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Player_PlayerState>(
    Player_PlayerState_descriptor(), name, value);
}
// ===================================================================

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  static const Player* internal_default_instance();

  void Swap(Player* other);

  // implements Message ----------------------------------------------

  inline Player* New() const { return New(NULL); }

  Player* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Player* other);
  void UnsafeMergeFrom(const Player& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Player_PlayerState PlayerState;
  static const PlayerState Lobby =
    Player_PlayerState_Lobby;
  static const PlayerState InGame =
    Player_PlayerState_InGame;
  static const PlayerState LoggedOut =
    Player_PlayerState_LoggedOut;
  static const PlayerState Challenged =
    Player_PlayerState_Challenged;
  static inline bool PlayerState_IsValid(int value) {
    return Player_PlayerState_IsValid(value);
  }
  static const PlayerState PlayerState_MIN =
    Player_PlayerState_PlayerState_MIN;
  static const PlayerState PlayerState_MAX =
    Player_PlayerState_PlayerState_MAX;
  static const int PlayerState_ARRAYSIZE =
    Player_PlayerState_PlayerState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlayerState_descriptor() {
    return Player_PlayerState_descriptor();
  }
  static inline const ::std::string& PlayerState_Name(PlayerState value) {
    return Player_PlayerState_Name(value);
  }
  static inline bool PlayerState_Parse(const ::std::string& name,
      PlayerState* value) {
    return Player_PlayerState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required int32 wins = 3;
  bool has_wins() const;
  void clear_wins();
  static const int kWinsFieldNumber = 3;
  ::google::protobuf::int32 wins() const;
  void set_wins(::google::protobuf::int32 value);

  // required int32 losses = 4;
  bool has_losses() const;
  void clear_losses();
  static const int kLossesFieldNumber = 4;
  ::google::protobuf::int32 losses() const;
  void set_losses(::google::protobuf::int32 value);

  // repeated string playHistory = 8;
  int playhistory_size() const;
  void clear_playhistory();
  static const int kPlayHistoryFieldNumber = 8;
  const ::std::string& playhistory(int index) const;
  ::std::string* mutable_playhistory(int index);
  void set_playhistory(int index, const ::std::string& value);
  void set_playhistory(int index, const char* value);
  void set_playhistory(int index, const char* value, size_t size);
  ::std::string* add_playhistory();
  void add_playhistory(const ::std::string& value);
  void add_playhistory(const char* value);
  void add_playhistory(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& playhistory() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_playhistory();

  // required .Player.PlayerState playerState = 5;
  bool has_playerstate() const;
  void clear_playerstate();
  static const int kPlayerStateFieldNumber = 5;
  ::Player_PlayerState playerstate() const;
  void set_playerstate(::Player_PlayerState value);

  // required int32 clientId = 6;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIdFieldNumber = 6;
  ::google::protobuf::int32 clientid() const;
  void set_clientid(::google::protobuf::int32 value);

  // required int32 challengeId = 7;
  bool has_challengeid() const;
  void clear_challengeid();
  static const int kChallengeIdFieldNumber = 7;
  ::google::protobuf::int32 challengeid() const;
  void set_challengeid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Player)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_wins();
  inline void clear_has_wins();
  inline void set_has_losses();
  inline void clear_has_losses();
  inline void set_has_playerstate();
  inline void clear_has_playerstate();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_challengeid();
  inline void clear_has_challengeid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> playhistory_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 wins_;
  ::google::protobuf::int32 losses_;
  int playerstate_;
  ::google::protobuf::int32 clientid_;
  ::google::protobuf::int32 challengeid_;
  friend void  protobuf_InitDefaults_protoTest_2eproto_impl();
  friend void  protobuf_AddDesc_protoTest_2eproto_impl();
  friend void protobuf_AssignDesc_protoTest_2eproto();
  friend void protobuf_ShutdownFile_protoTest_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Player> Player_default_instance_;

// -------------------------------------------------------------------

class Leaderboard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Leaderboard) */ {
 public:
  Leaderboard();
  virtual ~Leaderboard();

  Leaderboard(const Leaderboard& from);

  inline Leaderboard& operator=(const Leaderboard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Leaderboard& default_instance();

  static const Leaderboard* internal_default_instance();

  void Swap(Leaderboard* other);

  // implements Message ----------------------------------------------

  inline Leaderboard* New() const { return New(NULL); }

  Leaderboard* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Leaderboard& from);
  void MergeFrom(const Leaderboard& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Leaderboard* other);
  void UnsafeMergeFrom(const Leaderboard& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string winners = 1;
  int winners_size() const;
  void clear_winners();
  static const int kWinnersFieldNumber = 1;
  const ::std::string& winners(int index) const;
  ::std::string* mutable_winners(int index);
  void set_winners(int index, const ::std::string& value);
  void set_winners(int index, const char* value);
  void set_winners(int index, const char* value, size_t size);
  ::std::string* add_winners();
  void add_winners(const ::std::string& value);
  void add_winners(const char* value);
  void add_winners(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& winners() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_winners();

  // repeated string losers = 2;
  int losers_size() const;
  void clear_losers();
  static const int kLosersFieldNumber = 2;
  const ::std::string& losers(int index) const;
  ::std::string* mutable_losers(int index);
  void set_losers(int index, const ::std::string& value);
  void set_losers(int index, const char* value);
  void set_losers(int index, const char* value, size_t size);
  ::std::string* add_losers();
  void add_losers(const ::std::string& value);
  void add_losers(const char* value);
  void add_losers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& losers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_losers();

  // @@protoc_insertion_point(class_scope:Leaderboard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> winners_;
  ::google::protobuf::RepeatedPtrField< ::std::string> losers_;
  friend void  protobuf_InitDefaults_protoTest_2eproto_impl();
  friend void  protobuf_AddDesc_protoTest_2eproto_impl();
  friend void protobuf_AssignDesc_protoTest_2eproto();
  friend void protobuf_ShutdownFile_protoTest_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Leaderboard> Leaderboard_default_instance_;

// -------------------------------------------------------------------

class Army : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Army) */ {
 public:
  Army();
  virtual ~Army();

  Army(const Army& from);

  inline Army& operator=(const Army& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Army& default_instance();

  static const Army* internal_default_instance();

  void Swap(Army* other);

  // implements Message ----------------------------------------------

  inline Army* New() const { return New(NULL); }

  Army* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Army& from);
  void MergeFrom(const Army& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Army* other);
  void UnsafeMergeFrom(const Army& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 archers = 1;
  bool has_archers() const;
  void clear_archers();
  static const int kArchersFieldNumber = 1;
  ::google::protobuf::int32 archers() const;
  void set_archers(::google::protobuf::int32 value);

  // required int32 swordsman = 2;
  bool has_swordsman() const;
  void clear_swordsman();
  static const int kSwordsmanFieldNumber = 2;
  ::google::protobuf::int32 swordsman() const;
  void set_swordsman(::google::protobuf::int32 value);

  // required int32 cavalry = 3;
  bool has_cavalry() const;
  void clear_cavalry();
  static const int kCavalryFieldNumber = 3;
  ::google::protobuf::int32 cavalry() const;
  void set_cavalry(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Army)
 private:
  inline void set_has_archers();
  inline void clear_has_archers();
  inline void set_has_swordsman();
  inline void clear_has_swordsman();
  inline void set_has_cavalry();
  inline void clear_has_cavalry();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 archers_;
  ::google::protobuf::int32 swordsman_;
  ::google::protobuf::int32 cavalry_;
  friend void  protobuf_InitDefaults_protoTest_2eproto_impl();
  friend void  protobuf_AddDesc_protoTest_2eproto_impl();
  friend void protobuf_AssignDesc_protoTest_2eproto();
  friend void protobuf_ShutdownFile_protoTest_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Army> Army_default_instance_;

// -------------------------------------------------------------------

class Game : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Game) */ {
 public:
  Game();
  virtual ~Game();

  Game(const Game& from);

  inline Game& operator=(const Game& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Game& default_instance();

  static const Game* internal_default_instance();

  void Swap(Game* other);

  // implements Message ----------------------------------------------

  inline Game* New() const { return New(NULL); }

  Game* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Game& from);
  void MergeFrom(const Game& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Game* other);
  void UnsafeMergeFrom(const Game& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Army army1 = 1;
  bool has_army1() const;
  void clear_army1();
  static const int kArmy1FieldNumber = 1;
  const ::Army& army1() const;
  ::Army* mutable_army1();
  ::Army* release_army1();
  void set_allocated_army1(::Army* army1);

  // required .Army army2 = 2;
  bool has_army2() const;
  void clear_army2();
  static const int kArmy2FieldNumber = 2;
  const ::Army& army2() const;
  ::Army* mutable_army2();
  ::Army* release_army2();
  void set_allocated_army2(::Army* army2);

  // @@protoc_insertion_point(class_scope:Game)
 private:
  inline void set_has_army1();
  inline void clear_has_army1();
  inline void set_has_army2();
  inline void clear_has_army2();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Army* army1_;
  ::Army* army2_;
  friend void  protobuf_InitDefaults_protoTest_2eproto_impl();
  friend void  protobuf_AddDesc_protoTest_2eproto_impl();
  friend void protobuf_AssignDesc_protoTest_2eproto();
  friend void protobuf_ShutdownFile_protoTest_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Game> Game_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Player

// required string name = 1;
inline bool Player::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:Player.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player.name)
}
inline void Player::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player.name)
}
inline void Player::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player.name)
}
inline ::std::string* Player::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Player.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:Player.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Player.name)
}

// required string password = 2;
inline bool Player::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& Player::password() const {
  // @@protoc_insertion_point(field_get:Player.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Player.password)
}
inline void Player::set_password(const char* value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Player.password)
}
inline void Player::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Player.password)
}
inline ::std::string* Player::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:Player.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Player::release_password() {
  // @@protoc_insertion_point(field_release:Player.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Player::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Player.password)
}

// required int32 wins = 3;
inline bool Player::has_wins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player::set_has_wins() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player::clear_has_wins() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player::clear_wins() {
  wins_ = 0;
  clear_has_wins();
}
inline ::google::protobuf::int32 Player::wins() const {
  // @@protoc_insertion_point(field_get:Player.wins)
  return wins_;
}
inline void Player::set_wins(::google::protobuf::int32 value) {
  set_has_wins();
  wins_ = value;
  // @@protoc_insertion_point(field_set:Player.wins)
}

// required int32 losses = 4;
inline bool Player::has_losses() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::set_has_losses() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player::clear_has_losses() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player::clear_losses() {
  losses_ = 0;
  clear_has_losses();
}
inline ::google::protobuf::int32 Player::losses() const {
  // @@protoc_insertion_point(field_get:Player.losses)
  return losses_;
}
inline void Player::set_losses(::google::protobuf::int32 value) {
  set_has_losses();
  losses_ = value;
  // @@protoc_insertion_point(field_set:Player.losses)
}

// repeated string playHistory = 8;
inline int Player::playhistory_size() const {
  return playhistory_.size();
}
inline void Player::clear_playhistory() {
  playhistory_.Clear();
}
inline const ::std::string& Player::playhistory(int index) const {
  // @@protoc_insertion_point(field_get:Player.playHistory)
  return playhistory_.Get(index);
}
inline ::std::string* Player::mutable_playhistory(int index) {
  // @@protoc_insertion_point(field_mutable:Player.playHistory)
  return playhistory_.Mutable(index);
}
inline void Player::set_playhistory(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Player.playHistory)
  playhistory_.Mutable(index)->assign(value);
}
inline void Player::set_playhistory(int index, const char* value) {
  playhistory_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Player.playHistory)
}
inline void Player::set_playhistory(int index, const char* value, size_t size) {
  playhistory_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Player.playHistory)
}
inline ::std::string* Player::add_playhistory() {
  // @@protoc_insertion_point(field_add_mutable:Player.playHistory)
  return playhistory_.Add();
}
inline void Player::add_playhistory(const ::std::string& value) {
  playhistory_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Player.playHistory)
}
inline void Player::add_playhistory(const char* value) {
  playhistory_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Player.playHistory)
}
inline void Player::add_playhistory(const char* value, size_t size) {
  playhistory_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Player.playHistory)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Player::playhistory() const {
  // @@protoc_insertion_point(field_list:Player.playHistory)
  return playhistory_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Player::mutable_playhistory() {
  // @@protoc_insertion_point(field_mutable_list:Player.playHistory)
  return &playhistory_;
}

// required .Player.PlayerState playerState = 5;
inline bool Player::has_playerstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Player::set_has_playerstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Player::clear_has_playerstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Player::clear_playerstate() {
  playerstate_ = 0;
  clear_has_playerstate();
}
inline ::Player_PlayerState Player::playerstate() const {
  // @@protoc_insertion_point(field_get:Player.playerState)
  return static_cast< ::Player_PlayerState >(playerstate_);
}
inline void Player::set_playerstate(::Player_PlayerState value) {
  assert(::Player_PlayerState_IsValid(value));
  set_has_playerstate();
  playerstate_ = value;
  // @@protoc_insertion_point(field_set:Player.playerState)
}

// required int32 clientId = 6;
inline bool Player::has_clientid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Player::set_has_clientid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Player::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Player::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 Player::clientid() const {
  // @@protoc_insertion_point(field_get:Player.clientId)
  return clientid_;
}
inline void Player::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
  // @@protoc_insertion_point(field_set:Player.clientId)
}

// required int32 challengeId = 7;
inline bool Player::has_challengeid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Player::set_has_challengeid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Player::clear_has_challengeid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Player::clear_challengeid() {
  challengeid_ = 0;
  clear_has_challengeid();
}
inline ::google::protobuf::int32 Player::challengeid() const {
  // @@protoc_insertion_point(field_get:Player.challengeId)
  return challengeid_;
}
inline void Player::set_challengeid(::google::protobuf::int32 value) {
  set_has_challengeid();
  challengeid_ = value;
  // @@protoc_insertion_point(field_set:Player.challengeId)
}

inline const Player* Player::internal_default_instance() {
  return &Player_default_instance_.get();
}
// -------------------------------------------------------------------

// Leaderboard

// repeated string winners = 1;
inline int Leaderboard::winners_size() const {
  return winners_.size();
}
inline void Leaderboard::clear_winners() {
  winners_.Clear();
}
inline const ::std::string& Leaderboard::winners(int index) const {
  // @@protoc_insertion_point(field_get:Leaderboard.winners)
  return winners_.Get(index);
}
inline ::std::string* Leaderboard::mutable_winners(int index) {
  // @@protoc_insertion_point(field_mutable:Leaderboard.winners)
  return winners_.Mutable(index);
}
inline void Leaderboard::set_winners(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Leaderboard.winners)
  winners_.Mutable(index)->assign(value);
}
inline void Leaderboard::set_winners(int index, const char* value) {
  winners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Leaderboard.winners)
}
inline void Leaderboard::set_winners(int index, const char* value, size_t size) {
  winners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Leaderboard.winners)
}
inline ::std::string* Leaderboard::add_winners() {
  // @@protoc_insertion_point(field_add_mutable:Leaderboard.winners)
  return winners_.Add();
}
inline void Leaderboard::add_winners(const ::std::string& value) {
  winners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Leaderboard.winners)
}
inline void Leaderboard::add_winners(const char* value) {
  winners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Leaderboard.winners)
}
inline void Leaderboard::add_winners(const char* value, size_t size) {
  winners_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Leaderboard.winners)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Leaderboard::winners() const {
  // @@protoc_insertion_point(field_list:Leaderboard.winners)
  return winners_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Leaderboard::mutable_winners() {
  // @@protoc_insertion_point(field_mutable_list:Leaderboard.winners)
  return &winners_;
}

// repeated string losers = 2;
inline int Leaderboard::losers_size() const {
  return losers_.size();
}
inline void Leaderboard::clear_losers() {
  losers_.Clear();
}
inline const ::std::string& Leaderboard::losers(int index) const {
  // @@protoc_insertion_point(field_get:Leaderboard.losers)
  return losers_.Get(index);
}
inline ::std::string* Leaderboard::mutable_losers(int index) {
  // @@protoc_insertion_point(field_mutable:Leaderboard.losers)
  return losers_.Mutable(index);
}
inline void Leaderboard::set_losers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Leaderboard.losers)
  losers_.Mutable(index)->assign(value);
}
inline void Leaderboard::set_losers(int index, const char* value) {
  losers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Leaderboard.losers)
}
inline void Leaderboard::set_losers(int index, const char* value, size_t size) {
  losers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Leaderboard.losers)
}
inline ::std::string* Leaderboard::add_losers() {
  // @@protoc_insertion_point(field_add_mutable:Leaderboard.losers)
  return losers_.Add();
}
inline void Leaderboard::add_losers(const ::std::string& value) {
  losers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Leaderboard.losers)
}
inline void Leaderboard::add_losers(const char* value) {
  losers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Leaderboard.losers)
}
inline void Leaderboard::add_losers(const char* value, size_t size) {
  losers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Leaderboard.losers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Leaderboard::losers() const {
  // @@protoc_insertion_point(field_list:Leaderboard.losers)
  return losers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Leaderboard::mutable_losers() {
  // @@protoc_insertion_point(field_mutable_list:Leaderboard.losers)
  return &losers_;
}

inline const Leaderboard* Leaderboard::internal_default_instance() {
  return &Leaderboard_default_instance_.get();
}
// -------------------------------------------------------------------

// Army

// required int32 archers = 1;
inline bool Army::has_archers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Army::set_has_archers() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Army::clear_has_archers() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Army::clear_archers() {
  archers_ = 0;
  clear_has_archers();
}
inline ::google::protobuf::int32 Army::archers() const {
  // @@protoc_insertion_point(field_get:Army.archers)
  return archers_;
}
inline void Army::set_archers(::google::protobuf::int32 value) {
  set_has_archers();
  archers_ = value;
  // @@protoc_insertion_point(field_set:Army.archers)
}

// required int32 swordsman = 2;
inline bool Army::has_swordsman() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Army::set_has_swordsman() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Army::clear_has_swordsman() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Army::clear_swordsman() {
  swordsman_ = 0;
  clear_has_swordsman();
}
inline ::google::protobuf::int32 Army::swordsman() const {
  // @@protoc_insertion_point(field_get:Army.swordsman)
  return swordsman_;
}
inline void Army::set_swordsman(::google::protobuf::int32 value) {
  set_has_swordsman();
  swordsman_ = value;
  // @@protoc_insertion_point(field_set:Army.swordsman)
}

// required int32 cavalry = 3;
inline bool Army::has_cavalry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Army::set_has_cavalry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Army::clear_has_cavalry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Army::clear_cavalry() {
  cavalry_ = 0;
  clear_has_cavalry();
}
inline ::google::protobuf::int32 Army::cavalry() const {
  // @@protoc_insertion_point(field_get:Army.cavalry)
  return cavalry_;
}
inline void Army::set_cavalry(::google::protobuf::int32 value) {
  set_has_cavalry();
  cavalry_ = value;
  // @@protoc_insertion_point(field_set:Army.cavalry)
}

inline const Army* Army::internal_default_instance() {
  return &Army_default_instance_.get();
}
// -------------------------------------------------------------------

// Game

// required .Army army1 = 1;
inline bool Game::has_army1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Game::set_has_army1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Game::clear_has_army1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Game::clear_army1() {
  if (army1_ != NULL) army1_->::Army::Clear();
  clear_has_army1();
}
inline const ::Army& Game::army1() const {
  // @@protoc_insertion_point(field_get:Game.army1)
  return army1_ != NULL ? *army1_
                         : *::Army::internal_default_instance();
}
inline ::Army* Game::mutable_army1() {
  set_has_army1();
  if (army1_ == NULL) {
    army1_ = new ::Army;
  }
  // @@protoc_insertion_point(field_mutable:Game.army1)
  return army1_;
}
inline ::Army* Game::release_army1() {
  // @@protoc_insertion_point(field_release:Game.army1)
  clear_has_army1();
  ::Army* temp = army1_;
  army1_ = NULL;
  return temp;
}
inline void Game::set_allocated_army1(::Army* army1) {
  delete army1_;
  army1_ = army1;
  if (army1) {
    set_has_army1();
  } else {
    clear_has_army1();
  }
  // @@protoc_insertion_point(field_set_allocated:Game.army1)
}

// required .Army army2 = 2;
inline bool Game::has_army2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Game::set_has_army2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Game::clear_has_army2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Game::clear_army2() {
  if (army2_ != NULL) army2_->::Army::Clear();
  clear_has_army2();
}
inline const ::Army& Game::army2() const {
  // @@protoc_insertion_point(field_get:Game.army2)
  return army2_ != NULL ? *army2_
                         : *::Army::internal_default_instance();
}
inline ::Army* Game::mutable_army2() {
  set_has_army2();
  if (army2_ == NULL) {
    army2_ = new ::Army;
  }
  // @@protoc_insertion_point(field_mutable:Game.army2)
  return army2_;
}
inline ::Army* Game::release_army2() {
  // @@protoc_insertion_point(field_release:Game.army2)
  clear_has_army2();
  ::Army* temp = army2_;
  army2_ = NULL;
  return temp;
}
inline void Game::set_allocated_army2(::Army* army2) {
  delete army2_;
  army2_ = army2;
  if (army2) {
    set_has_army2();
  } else {
    clear_has_army2();
  }
  // @@protoc_insertion_point(field_set_allocated:Game.army2)
}

inline const Game* Game::internal_default_instance() {
  return &Game_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Player_PlayerState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Player_PlayerState>() {
  return ::Player_PlayerState_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protoTest_2eproto__INCLUDED
